{"version":3,"sources":["tools.js","App.js","serviceWorker.js","index.js"],"names":["exports","getRandomInt","min","max","Math","ceil","floor","random","GET_NEXT_POSITION","up","x","y","right","down","left","Status","props","react_default","a","createElement","className","score","toString","padStart","Cell","value","Board","board","map","row","i","key","cell","j","App_Cell","App","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","getInitialState","initialState","getInitialBoard","snake","getInitialSnake","head","direction","isGameOver","isPaused","forEach","coordinates","push","spawnFood","startGame","_this2","loop","setInterval","tick","clearTimeout","slice","getNextPosition","length","isHit","setState","isFood","tail","shift","_coordinates","slicedToArray","_coordinates2","apply","toConsumableArray","BOARD_SIZE","isEmptySpot","clearInterval","_this3","App_Status","App_Board","react_keyboard_event_handler_default","handleKeys","onKeyEvent","togglePause","resetGame","indexOf","setDirection","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.fd491313.chunk.js","sourcesContent":["/* eslint-disable no-unused-vars */\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive).\n * The value is no lower than min (or the next integer greater than min\n * if min isn't an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * Using Math.round() will give you a non-uniform distribution!\n *\n * @param {Int} min minimum value, inclusive\n * @param {Int} max maximum value, inclusive\n */\nexports.getRandomInt = function (min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","import React, { Component } from 'react';\nimport KeyboardEventHandler from 'react-keyboard-event-handler';\nimport { getRandomInt } from './tools';\n\nimport './css/App.css';\n\nconst BOARD_SIZE = 20;\nconst FOOD_SCORE_VALUE = 1;\nconst FPS = 6;\nconst GET_NEXT_POSITION = {\n  up: (x, y) => ([x, y - 1]),\n  right: (x, y) => ([x + 1, y]),\n  down: (x, y) => ([x, y + 1]),\n  left: (x, y) => ([x - 1, y]),\n};\n\nconst Status = (props) => {\n  return <h2 className=\"status\">\n      Score: <span className=\"white f1\">{props.score.toString().padStart(8, '0')}</span>\n    </h2>;\n}\n\nconst Cell = (props) => {\n  return (\n    <div className={'cell ' + (props.value ? props.value : '')}></div>\n  );\n}\n\nconst Board = (props) => {\n  return (\n    <div className=\"board\">\n      {props.board.map((row, i) => {\n        return (\n          <div key={i} className=\"row\">\n            {row.map((cell, j) => {\n              return <Cell key={j} value={cell} />;\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = this.getInitialState();\n  }\n\n  getInitialState() {\n    const initialState = {\n      board: this.getInitialBoard(),\n      snake: this.getInitialSnake(),\n      head: [0, 3],\n      direction: 'down',\n      isGameOver: false,\n      isPaused: false,\n      score: 0\n    };\n\n    // Draw snake on the board\n    initialState.snake.forEach((coordinates) => {\n      initialState.board[coordinates[1]][coordinates[0]] = 'snake';\n    });\n\n    return initialState;\n  }\n\n  /**\n   * Empty initial board composed of a 2 dimensionnal array\n   * containing rows of cells.\n   * @todo :\n   * - make it a 1 demensionnal array ?\n   *   (and only create rows manually when looping over)\n   */\n  getInitialBoard() {\n    let board = [];\n    for (let i = 0; i < BOARD_SIZE; i++) {\n      let row = [];\n      for (let j = 0; j < BOARD_SIZE; j++) {\n        row.push(null);\n      }\n      board.push(row);\n    }\n\n    return board;\n  }\n\n  /**\n   * Get initial snake position\n   */\n  getInitialSnake() {\n    return [[0, 0], [0, 1], [0, 2], [0, 3]];\n  }\n\n  componentDidMount() {\n    this.spawnFood();\n    this.startGame();\n  }\n\n  /**\n   * Start game loop\n   */\n  startGame() {\n    this.loop = setInterval(() => {\n      if (!this.state.isPaused) {\n        this.tick();\n      }\n\n      if (this.state.isGameOver) {\n        clearTimeout(this.loop);\n      }\n    }, 1000 / FPS);\n  }\n\n  /**\n   * Represent a game loop.\n   * Inside it we :\n   * - compute snake move\n   * - update board accordingly\n   */\n  tick() {\n    // Copy arrays to avoid mutation.\n    const board = this.state.board.slice();\n    const snake = this.state.snake.slice();\n    let score = this.state.score;\n\n    // Get next head position.\n    const head = this.getNextPosition(snake[snake.length - 1]);\n\n    if (this.isHit(head)) {\n      // Stop the game if head collides with walls or body.\n      this.setState({\n        isGameOver: true,\n      });\n      return;\n    } else if (this.isFood(head)) {\n      // Pop another food when eating one.\n      this.spawnFood();\n      score += FOOD_SCORE_VALUE;\n    } else {\n      // Remove the last part of the snake only when NOT eating food.\n      // Keeping the last part when eating food expands the body by one.\n      let tail = snake[0];\n      board[tail[1]][tail[0]] = null;\n      snake.shift();\n    }\n\n    board[head[1]][head[0]] = 'snake';\n    snake.push(head);\n\n    this.setState({\n      board: board,\n      snake: snake,\n      score: score,\n    });\n  }\n\n  /**\n   * Check if coordinates are out of game bound,\n   * or if cell is already accupied by the snake body.\n   *\n   * @param {Array} coordinates Array containing x and y position.\n   */\n  isHit(coordinates) {\n    const [x, y] = coordinates;\n    return (\n      x >= BOARD_SIZE || x < 0\n      || y >= BOARD_SIZE || y < 0\n      || this.state.board[y][x] === 'snake'\n    )\n  }\n\n  /**\n   * Check is element at coordinates is food.\n   *\n   * @param {Array} coordinates\n   */\n  isFood(coordinates) {\n    const [x, y] = coordinates;\n    return (this.state.board[y][x] === 'food');\n  }\n\n  /**\n   * @param {Array} coordinates Array containing x and y position.\n   */\n  getNextPosition(coordinates) {\n    return GET_NEXT_POSITION[this.state.direction](...coordinates);\n  }\n\n  /**\n   * @param {String} key The name of pressed kewboard key.\n   */\n  setDirection(key) {\n    // Prevent changing to opposite or same direction.\n    if (this.state.direction === 'up' || this.state.direction === 'down') {\n      if (key === 'up' || key === 'down') {\n        return;\n      }\n    } else {\n      if (key === 'left' || key === 'right') {\n        return\n      }\n    }\n\n    this.setState({\n      direction: key\n    });\n  }\n\n  /**\n   * Spawn food at random coordinates.\n   * If spot is already taken, it will repeat the process\n   * @todo :\n   * - fix case when board is full, causes max call stack\n   *   `get available spots array.filter(EMPTY)`\n   * - board state should be only set inside tick function\n   */\n  spawnFood() {\n    const coordinates = [\n      getRandomInt(0, BOARD_SIZE - 1),\n      getRandomInt(0, BOARD_SIZE - 1),\n    ];\n\n    let isEmptySpot = true;\n    if (this.state.board[coordinates[1]][coordinates[0]]) {\n      isEmptySpot = false;\n    }\n\n    if (!isEmptySpot) {\n      // Get another random spot if spot is not available.\n      this.spawnFood();\n    } else {\n      const board = this.state.board.slice();\n      board[coordinates[1]][coordinates[0]] = 'food';\n      this.setState({\n        board: board\n      });\n    }\n  }\n\n  /**\n   * Reset game\n   */\n  resetGame() {\n    clearInterval(this.loop);\n    this.setState(this.getInitialState());\n    this.spawnFood();\n    this.startGame();\n  }\n\n  togglePause() {\n    this.setState({\n      isPaused: !this.state.isPaused,\n    });\n  }\n\n  render() {\n    return (\n      <div className={'app' + (this.state.isGameOver ? ' over' : '')}>\n        <Status\n          score={this.state.score}\n        />\n        <Board\n          board={this.state.board}\n          snake={this.state.snake}\n        />\n        <ul className=\"help\">\n          <li>Use the <kbd className=\"key\">Arrow</kbd> keys to move.</li>\n          <li>Press <kbd className=\"key\">Space</kbd> to pause/resume the game.</li>\n          <li>Press <kbd className=\"key\">Enter</kbd> to restart the game.</li>\n        </ul>\n        <KeyboardEventHandler\n          handleKeys={['up', 'right', 'down', 'left', 'space', 'enter']}\n          onKeyEvent={\n            (key) => {\n              if (key === 'space') {\n                this.togglePause();\n              }\n\n              if (key === 'enter') {\n                this.resetGame();\n              }\n\n              if (!this.state.isPaused) {\n                if (['up', 'right', 'down', 'left'].indexOf(key) >= 0) {\n                  this.setDirection(key);\n                }\n              }\n            }\n          }\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}